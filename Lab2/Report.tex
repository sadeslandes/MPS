\documentclass[12pt]{article}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[justification=centering]{caption}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{siunitx}

\lstset{ %
	%language=C,                % choose the language of the code
	basicstyle=\footnotesize,       % the size of the fonts that are used for the code
	                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	%frame=single,           % adds a frame around the code
	tabsize=2,          % sets default tabsize to 2 spaces
	captionpos=b,           % sets the caption-position to bottom
	breaklines=true,        % sets automatic line breaking
	breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\begin{document}
\title{Microprocessor Systems\\ Lab 1: IDE \&\ ANSI Display}
\author{Nick Choi \and Samuel Deslandes}
\date{8/26/16}
\maketitle
\pagebreak
\section{Introduction}
The overall goal of this lab is to become familiar with utilizing the registers on the 8051 as well as performing fundamental I/O operations with it. This lab also served as an introduction to the VT100 Terminal and the utilization of its ANSI escape sequences.

This lab was divided into 3 parts. The first was an exercise in basic terminal I/O in which a C program was written to await a user keystroke and, if printable, output it onto the terminal display. The second part was an enhancement of the first part with heavy usage of ANSI escape codes to format text on the display. The ANSI escape codes are special sequences beginning with \textless ESC\textgreater (\textbackslash033 in octal or \$1B in hex) which modify terminal behavior. This includes features such as underlined text, background/foreground color changes, changing the cursor position, selectable scrolling, and more. The third part of the lab involved configuring ports on the 8051 to be either inputs or outputs. In this part of the lab, hardware connected to the input port could be used to change the state of hardware connected to the output ports of the 8051. 

\section{Methods}
\subsection{Software}
The code for parts 1, 2 and 3 can be found in Appendix A, B and C respectively. All code was uploaded and run on the 8051 through the programming/debugging USB port. 	

\subsubsection{Part 1}
The C program for the first section of the lab was a straightforward application of using an external interrupt source, such as the grounding of a pushbutton, to generate an interrupt which would then cause text to be displayed on the terminal. External interrupt 0 (/INT0) was used as a the interrupt source for this lab; In order to configure the 8051 for this, interrupts must first be globally enabled by setting bit 7 of the ``Interrupt Enable" SRF (IE) as well as bit 0 of the same SRF to enable /INT0. These are bit addressable addresses which correspond to ``EA" and ``EX0" respectively. The operation mode of /INT0 can then be set to be active logic low triggered or falling edge triggered by clearing or setting bit 0 of the ``Timer Control" SFR (TCON), which is bit addressable as ``IT0". In this lab IT0 was set to be triggered by a negative falling edge (IT0 = 1) because it was no desirable to have multiple interrupts be generated if the user holds the pushbutton down. 

In order to interface the interrupt to the pushbutton the crossbar must also be configured to route /INT0 to a port pin. This can be done by setting bit 2 of the ``XBR1" SRF (XBR1 = 0x04). For the crossbar settings used in this section, /INT0 was routed to pin 2 on port 0, which must be configured as an input. This is done by using the P0MDOUT SFR to set P0.2 in open-drain mode, then by using the P0 SFR to set P0.2 to high impedance mode.  

When /INT0 is triggered the program's current operation is preempted by the interrupt service routine (ISR) associated with the interrupt generated. The instructions that take place in the ISR should be limited to only a small number of fast operations. Rather than executing a lengthy I/O operation such as ``printf()" here, a global variable is used as a flag which allows the rest of the program to determine whether an interrupt has occurred. All the ISR has to do in this case is set the flag. When declaring the ISR function, it is important to remember to include the interrupt's priority; /INT0 has a priority level of 0 (the highest priority).

The main function for this section is simple. Before entering the infinite loop the variable used as the interrupt flag is cleared. In the loop the program checks if the flag has been set by the ISR and if it has the desired text is printed to the display and the flag is cleared.

\subsubsection{Part 2}
The code for section 2 involved utilizing a timer interrupts to display elapsed time in multiples of a tenth of a second. This was done using two methods: An inaccurate method using rounding, and an exactly accurate method. Both methods operate using the same concepts. Timer0 is used to count from a starting value until it overflows, triggering the timer0 overflow interrupt. In the ISR the timer is set to its starting value and a global variable used to count the number of overflows is incremented. Since overflows happen at a fixed frequency, by counting the number of overflows the elapsed time may be measured. For example, in the case of the accurate timer an overflow happens once every \SI{50}{ms}. In 2 overflows a tenth of a second has elapsed. 

Interrupt configuration was performed similarly to section 1, one difference being that instead of setting the bit addressable address ``EX0", ``ET0" is now set. This enables timer0 interrupts rather than /INT0. 

For the inaccurate method timer0 was configured as a 16bit counter with a starting value of 0, using SYSCLK/12 as a base. For this method SYSCLK used the external oscillator for a frequency of \SI{22.1184}{MHz}. The calculations for how many overflows correspond to a tenth of a second were as follows:\\
\begin{equation}
	= \frac{\SI{22.1184e6}{counts}}{\SI{12}{sec}}*{\left(\frac{2^{16}- \SI{1}{counts}}{\SI{}{overflow}}\right)}^{-1}
\end{equation}
\begin{equation}
	= \frac{\SI{1843200}{counts}}{\SI{}{sec}}*\left(\frac{\SI{1}{overflow}}{\SI{65535}{counts}}\right)
\end{equation}
\begin{equation}
	= \frac{\SI{28.125}{overflows}}{\SI{}{sec}} = \frac{\SI{2.8125}{overflow}}{\SI{0.1}{sec}}
\end{equation}\\
Since the number of overflows must be an integer value, the $2.8125$ was rounded up to $3$.

As mentioned above, each time an overflow happed, the ISR incremented an overflow counting variable. In the infinite loop of the main function, whenever this counter had a value of $3$ the overflow counter would be reset to 0, a value counting the number of tenths of seconds elapsed would be incremented, and the elapsed time would be displayed. Since a tenth of a second is represented as a floating point data type ``printf\_fastf()'' had to be used instead of the usual ``printf()'' function.

For the accurate timing method timer0 was also configured as a 16bit counter, but had a starting value of $13,696$ or 0x3580, and used SYSCLK/48 as a base. For this method SYSCLK used the external oscillator and the phase-locked loop (PLL) which multiplies its source frequency by a programmable factor. This resulted in a SYSCLK frequency of \begin{math}
	\SI{22.1184}{MHz}*\left(\frac{9}{4}\right) = \SI{49.7664}{MHz}
\end{math}.  The calculations for how many overflows correspond to a tenth of a second were and how to determine the timer's starting value were as follows:\\
\begin{equation}
	\frac{\SI{49.7664e6}{counts}}{\SI{48}{sec}} = \frac{\SI{1036800}{counts}}{\SI{}{sec}}
\end{equation}\\
This represents the timer's counting speed. From this the number of counts per overflow necessary for one overflow to happen in a tenth of a second can be calculated.\\
\begin{equation}
	\frac{\SI{1036800}{counts}}{\SI{}{sec}}*\frac{1}{x}\frac{\SI{}{overflow}}{\SI{}{counts}} = \frac{\SI{1}{overflow}}{\SI{0.1}{sec}}
\end{equation}
\begin{equation}
 x = \SI{103680}{counts}
\end{equation}\\
This value, however, is too large to store in a 16bit variable. To remedy this it was halved, requiring \begin{math}
	\frac{103680}{2} = \SI{51840}{counts\per overflow}
\end{math} and 2 overflows in a tenth of a second. Since \SI{51840}{counts} are needed per overflow, the starting value of the timer should be \begin{math}
(2^{16}-1)-51840 = 13696
\end{math}, or 0x3580 in hex.

\subsubsection{Part 3}
The code for section 3 had a different application than the previous two sections and was more hardware focused. In terms of software, all of port 1 had to be configured to be in open-drain mode (input), and all of port 2 to push-pull mode (output). This was done by setting all of the bits of the P1MDOUT special function register (SFR) low, and all of those of P2MDOUT high. This should be done in the 'PORT\_INIT()' function. In the main function, all that had to be done was read the value of port 1 into port 2. This could be done using the P1 and P2 port SFRs. 

\subsection{Hardware}

Parts 1 and 2 of this lab did not require any hardware other than a serial-to-USB adapter in order to interface with the terminal.

In the third section of the lab, the pins on port 1 were connected to the input device, the potentiometer module, and pins on port 2 were connected to the output device, the LED module. Since there were only 4 potentiometers on the potentiometer module only the first 4 pins on each port were used (P1.0 - P1.3 and P2.0 - P2.3). These corresponded to pins 12, 13, 10, and 11 on the EVB for port 1, and 29, 30, 27, and 28 for port 2. A circuit diagram can be found in the appendices, section 5.4.1.

The input pins of the LED module have inverters incorporated into them so that whenever a logic high is applied to an input pin, the signal is changed to be a logic low. This inversion allows the LED to illuminate because there will be a voltage difference across the anode and cathode of the LED. If a logic low is applied to the input pin, the signal is changed to be a logic high. This removes the voltage difference between the anode and cathode of the LED and thus prevents the LED from lighting up. 
 
\section{Results}

By completing section one of the lab, a functioning C program was produced which read keyboard input and displayed it in an ANSI terminal. After completing section two, an improved version of the program from section one was produced. This version reacted to user input and manipulated the output of the ANSI terminal in several ways. The final deliverable was an LED module which was controlled by a potentiometer module. 

\section{Conclusion}

The end results of this lab ultimately matched with the initial goals however there were numerous instances where our system’s expected behavior did not correspond to its actual behavior. In order to properly produce the results that we needed for this lab, various hardware and software debugging techniques were utilized in order to verify the performance of each section of the lab. With some of these testing techniques, it was determined that the inputs to the 8051 utilize Schmitt triggers in order to prevent oscillating logic highs and logic lows. The use of Schmitt triggers makes the inputs of the 8051 more resilient to noise because they create separate thresholds for high and low values rather thancontent... having one shared boundary value. 

If more time was given to complete this lab assignment, additional conditional statements could be added to further enhance the responses of the ANSI terminal to user input. These statements could incorporate more escape sequences to display new error messages, to integrate hardware components to the error messages or to further manipulate the text formatting in the ANSI terminal. 


\pagebreak
\section{Appendices}
\subsection{Modified putget.h}
	\lstinputlisting{putget.h}
\subsection{Part 1}
	\subsubsection{Circuit Schematic}
		\begin{figure}[h]
			%\centering
			%\includegraphics{schematic1.png}
			\caption{Circuit schematic for part 1}
			\label{schematic}
		\end{figure} 
	\subsubsection{Code}
		\lstinputlisting{part1.c}
\subsection{Part 2}
	\subsubsection{Inaccurate timer code}
		\lstinputlisting{part2-1.c}
	\subsection{Accurate timer code}
		\lstinputlisting{part2-2.c}		

%\pagebreak
\subsection{Part 3}
	\subsubsection{Circuit Schematic}
		\begin{figure}[h]
			%\centering
		%	\includegraphics{schematic3.png}
			\caption{Circuit schematic for part 3}
			\label{schematic}
		\end{figure} 
	\pagebreak
	\subsubsection{Code}
		\lstinputlisting{part3.c}
	
	
\section{References} 
\noindent
``MPS Lab 1," in RPI ECSE Department, 2016. [Online]. Available: \url{http://www.rpi.edu/dept/ecse/mps/MPS_Lab_Ex1-IDE_ANSI.pdf}. Accessed: Sep. 17, 2016.\\
\newline\noindent
``C8051 Manual," in RPI ECSE Department, 1.4 ed., 2005. [Online]. Available: \url{https://www.ecse.rpi.edu/courses/CStudio/Silabs/C8051F12x-13x.pdf}. Accessed: Sep. 17, 2016.








\end{document}